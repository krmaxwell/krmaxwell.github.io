<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Project Euler | Technoskald]]></title>
  <link href="http://technoskald.github.io/blog/categories/project-euler/atom.xml" rel="self"/>
  <link href="http://technoskald.github.io/"/>
  <updated>2014-01-09T20:47:27-06:00</updated>
  <id>http://technoskald.github.io/</id>
  <author>
    <name><![CDATA[Kyle Maxwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Project Euler: Problem 4]]></title>
    <link href="http://technoskald.github.io/blog/2014/01/09/project-euler-problem-4/"/>
    <updated>2014-01-09T20:37:47-06:00</updated>
    <id>http://technoskald.github.io/blog/2014/01/09/project-euler-problem-4</id>
    <content type="html"><![CDATA[<h2><a href="http://projecteuler.net/problem=4">Problem 4</a>: A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99. Find the largest palindrome made from the product of two 3-digit numbers.</h2>

<p>Palindromic numbers make much more sense to humans than computers because we can look at a number as a series of symbols rather than a scalar value. And of course they only make sense in the context of a given base; clearly we must assume base 10 here, validated by the example given.</p>

<p>First we write a little function to determine whether a given integer value is a palindrome. Python&rsquo;s <a href="http://stackoverflow.com/a/509295/1569808">slice notation</a> makes this easy:</p>

<p>``` python Function to determine whether a number is a palindrome
def is_palindrome(n):</p>

<pre><code>return (str(n) == str(n)[::-1])
</code></pre>

<p><code>``
Basically, appending [</code>[::-1]`](<a href="http://stackoverflow.com/questions/509211/pythons-slice-notation#comment323779_509295">http://stackoverflow.com/questions/509211/pythons-slice-notation#comment323779_509295</a>) gives us the reverse of a list.</p>

<p>With that in mind, we just need a couple of for-loops to iterate over all pairs of three-digit numbers:</p>

<p>``` python Project Euler Problem 4 the obvious way
result = 0
for i in range(100, 1000):</p>

<pre><code>for j in range(100, 1000):
    n = i*j
    if (is_palindrome(n)) and n &gt; result:
        lasti = i
        lastj = j
        result = n
</code></pre>

<p>print &ldquo;%d is the product of %d and %d&rdquo; % (result, lasti, lastj)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler: Problem 3]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/26/project-euler-problem-3/"/>
    <updated>2013-12-26T20:00:31-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/26/project-euler-problem-3</id>
    <content type="html"><![CDATA[<h2><a href="http://projecteuler.net/problem=3">Problem 3</a>: The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ?</h2>

<p><a href="http://en.wikipedia.org/wiki/Integer_factorization">Factorization</a> is, computationally speaking, a Hard Problem. When mathematicians call a problem &ldquo;hard&rdquo;, we don&rsquo;t mean &ldquo;difficult for the human mind to comprehend&rdquo;, because that is subjective and subject to change. Remember, the differential calculus literally changed history when Newton and Leibniz first wrote about it, and now we teach it to kids in high school. No, what we mean in this case<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> is that it can&rsquo;t be solved in polynomial time &ndash; meaning that, for very large numbers, this takes infeasible amounts of time with everything we know about mathematics and computation right now. In fact, it&rsquo;s so hard that it forms the mathematical basis for public-key cryptography.</p>

<p>That doesn&rsquo;t mean we can&rsquo;t do it. It just means that for really, really big numbers, it takes a long time. So this problem isn&rsquo;t actually a large number, on the order of 10<sup>12</sup>. And lots of work has been done with this problem: in fact, it comes down to something called the &ldquo;Fundamental Theorem of Arithmetic&rdquo;, which is that every positive integer has a <em>unique</em> prime factorization.</p>

<p>To facilitate some problems later in Project Euler, I wrote a general-purpose factorization routine that does a little more than we need here.</p>

<p>``` python Integer factorization routine
def prime_factors(n):</p>

<pre><code>""" Return the prime factors of the given number. """
factors = {}
lastresult = n

# 1 is a special case
if n == 1:
    return {1: 1}

while lastresult != 1:
    c = 2
    while lastresult % c != 0:
        c += 1
if c in factors:
    factors[c] += 1
else:
    factors[c] = 1
    lastresult /= c

return factors
</code></pre>

<p>```</p>

<p>This will return a Python dict, where each key is a prime factor of the original number and the value of that key is the required power to which we need to raise that factor (e.g. <code>prime_factors(18)</code> returns <code>{2:1, 3:2}</code> for <tt>2<sup>1</sup> * 3<sup>2</sup></tt>).</p>

<p>Then we write a short script to call it with the appropriate number and print only the largest factor.</p>

<p><code>python Project Euler Problem 3 wrapper code
n = 600851475143
factors = prime_factors(n)
print "Largest prime factor of %d is %d" % (n, max(factors.keys()))
</code></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>The &ldquo;hardness&rdquo; of a problem in mathematics is called its &ldquo;complexity&rdquo;. Computational complexity theory is a well-established and important field all on its own.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler: Problem 2]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/25/project-euler-problem-2/"/>
    <updated>2013-12-25T13:52:24-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/25/project-euler-problem-2</id>
    <content type="html"><![CDATA[<p><em>NB: This is a repost of something I wrote on an old blog. Original post <a href="http://funcdata.wordpress.com/2012/05/11/project-euler-problem-2/">here</a>. Minor edits / additions to update for this newer context.</em></p>

<h2><a href="https://projecteuler.net/problem=2">Problem 2</a>: Each new term in the <a href="http://mathworld.wolfram.com/FibonacciNumber.html">Fibonacci sequence</a> is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,&hellip; By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</h2>

<p>As with problem 1, we could solve this with a traditional imperative approach:</p>

<p>``` python Project Euler Problem 2 the Traditional Way
n=0
a=1
b=2
print &ldquo;Calculating sum&hellip;&rdquo;
while (b &lt;= 4000000):</p>

<pre><code>print "a=",a," b=",b
if (b % 2) == 0:
    n += b
a,b = b,a+b
</code></pre>

<p>print &ldquo;Sum is &rdquo;,n
```</p>

<p>But we can streamline this. First, we observe that F<sub>1</sub> and F<sub>2</sub> (1 and 1, respectively) sum to F<sub>3</sub> = 2. We can also see that F<sub>4</sub>, as the sum of an odd and even, will therefore also be odd, as will F<sub>5</sub> due to being the sum of an even and odd. Clearly every third term must always be even, with the rest odd. So we only need to calculate every third term in the Fibonacci sequence. A bit of high school algebra shows us that:</p>

<p><tt>
F<sub>3</sub> = F<sub>1</sub> + F<sub>2</sub> = F<sub>1</sub> + F<sub>0</sub> + F<sub>1</sub> = F<sub>0</sub> + 2F<sub>1</sub>
</tt></p>

<p><tt>
F<sub>4</sub> = F<sub>2</sub> + F<sub>3</sub> = (F<sub>0</sub> + F<sub>1</sub>) + (F<sub>0</sub> + 2F<sub>1</sub>) = 2F<sub>0</sub> + 3F<sub>1</sub>
</tt></p>

<p>This means we can always skip ahead and just sum those terms.</p>

<p>Now we introduce the concept of a <a href="http://docs.python.org/dev/howto/functional.html#generators">generator</a> in Python. A generator function doesn&rsquo;t have a normal <code>return</code> statement. Instead, it uses <code>yield</code>, which &ldquo;pauses&rdquo; the function and returns a value. But the next time you call the generator to return another value, Python will &ldquo;unpause&rdquo; it and continue processing until it yields (returns) another value. (I&rsquo;ve simplified a bit here because I hate objects.) This effectively creates a list using <strong>list comprehension</strong>, similar to what we did in Problem 1 with the <code>i for i in range()</code> syntax.</p>

<p>So to <a href="https://github.com/technoskald/funcdata/blob/master/projecteuler/p002.py">solve the problem</a>, we write a modified Fibonacci sequence generator and just print its sum. Note that we avoid multiplication as a speed optimization; this actually made a significant difference!</p>

<p>``` python Project Euler Problem 2 the Generator Way
def modfib():</p>

<pre><code>a,b = 0,1
while b &lt; 4000000:
    a,b = a + b + b, a + a + b + b + b
    yield a
</code></pre>

<p>print sum(modfib())
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler: Problem 1]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/25/project-euler-problem-1/"/>
    <updated>2013-12-25T13:28:12-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/25/project-euler-problem-1</id>
    <content type="html"><![CDATA[<p><em>NB: This is a repost of something I wrote on an old blog. Original post <a href="http://funcdata.wordpress.com/2012/05/11/project-euler-problem-1/">here</a>. Minor edits / additions to update for this newer context.</em></p>

<h2><a href="https://projecteuler.net/problem=1">Problem 1</a>: Find the sum of all the multiples of 3 or 5 below 1000.</h2>

<p>My <a href="https://github.com/technoskald/projecteuler/blob/master/prob1.py">original solution</a> for this problem, like almost all the others, uses old-school imperative programming that we can do in almost any language.</p>

<p>``` python Project Euler Problem 1 the Easy Way
n=0
for i in range(1000):</p>

<pre><code>if ((i % 3) == 0) or ((i % 5) == 0):
    n += i
</code></pre>

<p>print n
```</p>

<p>More to the point, we can also <a href="https://github.com/technoskald/funcdata/blob/master/projecteuler/p001.py">do this</a> in idiomatic Python:</p>

<p><code>python Project Euler Problem 1 the Pythonic Way
print sum(i for i in range(1,1000) if i%3==0 or i%5==0)
</code></p>

<p>Both give the correct answer<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, but we used an <a href="http://docs.python.org/glossary.html#term-iterable">iterable</a> (sequence) in the second case to do the same thing as the <code>for</code> loop in the first example. We also don&rsquo;t need to maintain our own summation variable like <code>n</code>. Because of the small range of numbers we need to consider<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, I couldn&rsquo;t find any significant difference in the average run times of these two programs. And I&rsquo;ve wanted to explore <a href="http://en.wikipedia.org/wiki/Functional_programming">functional programming</a>, too.</p>

<p><code>python Project Euler Problem 1 the Functional Way
print sum(list(set(range(0,1000,3) + range(0,1000,5))))
</code></p>

<p>This avoids maintaining <em>any</em> internal state like we did with the <code>i</code> variable above. For purposes of functional programming, I think that this would have been the optimal solution.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I won&rsquo;t list the actual problem answers here. I know somebody can just copy and paste the code, but printing the actual answer as opposed to explaining how to solve it feels too much like cheating.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>In some later problems, I&rsquo;ll just get any needed parameters from the command line to facilitate testing and debugging.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
