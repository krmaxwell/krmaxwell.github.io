<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Technoskald]]></title>
  <link href="http://technoskald.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://technoskald.github.io/"/>
  <updated>2013-12-29T14:57:12-06:00</updated>
  <id>http://technoskald.github.io/</id>
  <author>
    <name><![CDATA[Kyle Maxwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2014 Tech goals]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/29/2014-tech-goals/"/>
    <updated>2013-12-29T14:37:38-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/29/2014-tech-goals</id>
    <content type="html"><![CDATA[<p>While the calendar will flip in a few days, I&rsquo;ve had some time off and and naturally have spent some time thinking about the future. What do I want to learn and improve in my technical skills over the next year or so? Most of the following can be summed up in two &ldquo;meta goals&rdquo;: <strong>write more code</strong> and <strong>get back to math and computer science.</strong></p>

<p>At the moment, I plan to work primarily in Python and C,  although that could change depending on projects and other similar factors. Today, I write most of my <a href="http://osrc.dfm.io/technoskald">open source code</a> in Python, and my closed source code for work leans even more heavily in that direction. C was my first love, though, and I still use a subset of it when working with Arduino. Other languages might crop up for specific projects, I suppose.</p>

<ol>
<li><strong>Submit a solid proposal to speak at DEFCON.</strong> I have no direct control over the acceptance of my proposal, but I can make sure that I work on something cool and submit a proposal that&rsquo;s worthy of serious consideration. Almost certainly this will deal with OSINT or network forensics.</li>
<li><strong>Complete the <a href="http://www.matasano.com/articles/crypto-challenges/">Matasano Crypto Challenges</a></strong> This will help me achieve a good hacker-level understanding of cryptography. Recent news events provide part of the motivation to learn a lot more about all this.</li>
<li><strong>Complete at least 100 problems from <a href="http://projecteuler.net">Project Euler</a>, including writeups.</strong> This project scratches a number of different itches for me, all in good ways.</li>
<li><strong>Build at least one really cool hardware project.</strong> I have a recent interest in hardware hacking, mostly around the so-called &ldquo;Internet of Things&rdquo;, and so (likely in conjunction with my daughter) I want to build something cool, albeit undetermined right now.</li>
</ol>


<p>For clarity&rsquo;s sake, of course I have other things I want to accomplish during the next few months to a year. Some of them almost fit here (more educational advocacy and volunteerism) and some don&rsquo;t (personal and family goals). But the above looks to me like a solid set of things to work on.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler: Problem 3]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/26/project-euler-problem-3/"/>
    <updated>2013-12-26T20:00:31-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/26/project-euler-problem-3</id>
    <content type="html"><![CDATA[<h2><a href="http://projecteuler.net/problem=3">Problem 3</a>: The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ?</h2>

<p><a href="http://en.wikipedia.org/wiki/Integer_factorization">Factorization</a> is, computationally speaking, a Hard Problem. When mathematicians call a problem &ldquo;hard&rdquo;, we don&rsquo;t mean &ldquo;difficult for the human mind to comprehend&rdquo;, because that is subjective and subject to change. Remember, the differential calculus literally changed history when Newton and Leibniz first wrote about it, and now we teach it to kids in high school. No, what we mean in this case<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> is that it can&rsquo;t be solved in polynomial time &ndash; meaning that, for very large numbers, this takes infeasible amounts of time with everything we know about mathematics and computation right now. In fact, it&rsquo;s so hard that it forms the mathematical basis for public-key cryptography.</p>

<p>That doesn&rsquo;t mean we can&rsquo;t do it. It just means that for really, really big numbers, it takes a long time. So this problem isn&rsquo;t actually a large number, on the order of 10<sup>12</sup>. And lots of work has been done with this problem: in fact, it comes down to something called the &ldquo;Fundamental Theorem of Arithmetic&rdquo;, which is that every positive integer has a <em>unique</em> prime factorization.</p>

<p>To facilitate some problems later in Project Euler, I wrote a general-purpose factorization routine that does a little more than we need here.</p>

<p>``` python Integer factorization routine
def prime_factors(n):</p>

<pre><code>""" Return the prime factors of the given number. """
factors = {}
lastresult = n

# 1 is a special case
if n == 1:
    return {1: 1}

while lastresult != 1:
    c = 2
    while lastresult % c != 0:
        c += 1
if c in factors:
    factors[c] += 1
else:
    factors[c] = 1
    lastresult /= c

return factors
</code></pre>

<p>```</p>

<p>This will return a Python dict, where each key is a prime factor of the original number and the value of that key is the required power to which we need to raise that factor (e.g. <code>prime_factors(18)</code> returns <code>{2:1, 3:2}</code> for <tt>2<sup>1</sup> * 3<sup>2</sup></tt>).</p>

<p>Then we write a short script to call it with the appropriate number and print only the largest factor.</p>

<p><code>python Project Euler Problem 3 wrapper code
n = 600851475143
factors = prime_factors(n)
print "Largest prime factor of %d is %d" % (n, max(factors.keys()))
</code></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>The &ldquo;hardness&rdquo; of a problem in mathematics is called its &ldquo;complexity&rdquo;. Computational complexity theory is a well-established and important field all on its own.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler: Problem 2]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/25/project-euler-problem-2/"/>
    <updated>2013-12-25T13:52:24-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/25/project-euler-problem-2</id>
    <content type="html"><![CDATA[<p><em>NB: This is a repost of something I wrote on an old blog. Original post <a href="http://funcdata.wordpress.com/2012/05/11/project-euler-problem-2/">here</a>. Minor edits / additions to update for this newer context.</em></p>

<h2><a href="https://projecteuler.net/problem=2">Problem 2</a>: Each new term in the <a href="http://mathworld.wolfram.com/FibonacciNumber.html">Fibonacci sequence</a> is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,&hellip; By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</h2>

<p>As with problem 1, we could solve this with a traditional imperative approach:</p>

<p>``` python Project Euler Problem 2 the Traditional Way
n=0
a=1
b=2
print &ldquo;Calculating sum&hellip;&rdquo;
while (b &lt;= 4000000):</p>

<pre><code>print "a=",a," b=",b
if (b % 2) == 0:
    n += b
a,b = b,a+b
</code></pre>

<p>print &ldquo;Sum is &rdquo;,n
```</p>

<p>But we can streamline this. First, we observe that F<sub>1</sub> and F<sub>2</sub> (1 and 1, respectively) sum to F<sub>3</sub> = 2. We can also see that F<sub>4</sub>, as the sum of an odd and even, will therefore also be odd, as will F<sub>5</sub> due to being the sum of an even and odd. Clearly every third term must always be even, with the rest odd. So we only need to calculate every third term in the Fibonacci sequence. A bit of high school algebra shows us that:</p>

<p><tt>
F<sub>3</sub> = F<sub>1</sub> + F<sub>2</sub> = F<sub>1</sub> + F<sub>0</sub> + F<sub>1</sub> = F<sub>0</sub> + 2F<sub>1</sub>
</tt></p>

<p><tt>
F<sub>4</sub> = F<sub>2</sub> + F<sub>3</sub> = (F<sub>0</sub> + F<sub>1</sub>) + (F<sub>0</sub> + 2F<sub>1</sub>) = 2F<sub>0</sub> + 3F<sub>1</sub>
</tt></p>

<p>This means we can always skip ahead and just sum those terms.</p>

<p>Now we introduce the concept of a <a href="http://docs.python.org/dev/howto/functional.html#generators">generator</a> in Python. A generator function doesn&rsquo;t have a normal <code>return</code> statement. Instead, it uses <code>yield</code>, which &ldquo;pauses&rdquo; the function and returns a value. But the next time you call the generator to return another value, Python will &ldquo;unpause&rdquo; it and continue processing until it yields (returns) another value. (I&rsquo;ve simplified a bit here because I hate objects.) This effectively creates a list using <strong>list comprehension</strong>, similar to what we did in Problem 1 with the <code>i for i in range()</code> syntax.</p>

<p>So to <a href="https://github.com/technoskald/funcdata/blob/master/projecteuler/p002.py">solve the problem</a>, we write a modified Fibonacci sequence generator and just print its sum. Note that we avoid multiplication as a speed optimization; this actually made a significant difference!</p>

<p>``` python Project Euler Problem 2 the Generator Way
def modfib():</p>

<pre><code>a,b = 0,1
while b &lt; 4000000:
    a,b = a + b + b, a + a + b + b + b
    yield a
</code></pre>

<p>print sum(modfib())
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler: Problem 1]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/25/project-euler-problem-1/"/>
    <updated>2013-12-25T13:28:12-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/25/project-euler-problem-1</id>
    <content type="html"><![CDATA[<p><em>NB: This is a repost of something I wrote on an old blog. Original post <a href="http://funcdata.wordpress.com/2012/05/11/project-euler-problem-1/">here</a>. Minor edits / additions to update for this newer context.</em></p>

<h2><a href="https://projecteuler.net/problem=1">Problem 1</a>: Find the sum of all the multiples of 3 or 5 below 1000.</h2>

<p>My <a href="https://github.com/technoskald/projecteuler/blob/master/prob1.py">original solution</a> for this problem, like almost all the others, uses old-school imperative programming that we can do in almost any language.</p>

<p>``` python Project Euler Problem 1 the Easy Way
n=0
for i in range(1000):</p>

<pre><code>if ((i % 3) == 0) or ((i % 5) == 0):
    n += i
</code></pre>

<p>print n
```</p>

<p>More to the point, we can also <a href="https://github.com/technoskald/funcdata/blob/master/projecteuler/p001.py">do this</a> in idiomatic Python:</p>

<p><code>python Project Euler Problem 1 the Pythonic Way
print sum(i for i in range(1,1000) if i%3==0 or i%5==0)
</code></p>

<p>Both give the correct answer<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, but we used an <a href="http://docs.python.org/glossary.html#term-iterable">iterable</a> (sequence) in the second case to do the same thing as the <code>for</code> loop in the first example. We also don&rsquo;t need to maintain our own summation variable like <code>n</code>. Because of the small range of numbers we need to consider<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, I couldn&rsquo;t find any significant difference in the average run times of these two programs. And I&rsquo;ve wanted to explore <a href="http://en.wikipedia.org/wiki/Functional_programming">functional programming</a>, too.</p>

<p><code>python Project Euler Problem 1 the Functional Way
print sum(list(set(range(0,1000,3) + range(0,1000,5))))
</code></p>

<p>This avoids maintaining <em>any</em> internal state like we did with the <code>i</code> variable above. For purposes of functional programming, I think that this would have been the optimal solution.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I won&rsquo;t list the actual problem answers here. I know somebody can just copy and paste the code, but printing the actual answer as opposed to explaining how to solve it feels too much like cheating.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>In some later problems, I&rsquo;ll just get any needed parameters from the command line to facilitate testing and debugging.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Computers versus telescopes]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/24/computers-versus-telescopes/"/>
    <updated>2013-12-24T21:11:48-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/24/computers-versus-telescopes</id>
    <content type="html"><![CDATA[<p><blockquote><p>Computer science is no more about computers than astronomy is about telescopes.</p><footer><strong>Michael R Fellows?</strong> <cite><a href="http://en.wikiquote.org/wiki/Computer%20science#Disputed">http://en.wikiquote.org/wiki/Computer%20science#Disputed</a></cite></footer></blockquote></p>

<p>Lots of folks have written in the past about the distinction between computer science and programming. A comment on Twitter reminded me of this again, but in an odd direction: the commenter expressed some dissatisfaction about having to learn some of the <em>history</em> of computer science while learning to program.</p>

<p>From a certain perspective, I can understand. Folks just dabbling in something like <a href="http://csedweek.org">The Hour of Code</a> might not have the interest or motivation right away to learn about Ada Lovelace and John von Neumann and Alan Turing. They likely have the motivation just to understand the whole idea of giving specific commands to a computer and thinking in advance of possible things that could happen &ndash; the mental framework that we coders take completely for granted.</p>

<p>But at the same time: learning the history of computer science matters the same way it does in any discipline. Hobbyists buying telescopes for family outings may not want to learn about, say, Galileo and Hubble and Newton (to play on the analogy in the opening quote). But once they start to take it seriously and graduate to a motivated amateur, they&rsquo;ll need to understand who those men were and why that matters.</p>

<p>The <a href="http://cs.saddleback.edu/michele/Teaching/CS1A/Slides/Topic%201%20-%20History%20-%202up.pdf">history of computer science</a> may not have the depth and twists that, say, physics does. But it has its own <a href="http://www.bbc.co.uk/news/technology-25495315">drama</a> worth understanding.</p>
]]></content>
  </entry>
  
</feed>
